---
title: "CensusAPI"
author: "Kyle Radican and Niah Venable"
date: "2025-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## "onGEO GEOVisualization Course: Census API and WebMapping script



```{r lib}

# setwd() function sets the working directory that you identify for you
setwd("C:/XXX/")

# Libraries
# Libraries are essentially the software packages that provide the functions 
# That you will use to manipulate and change the data
# Tidyverse is a library that is used to manipulate data in an easy to use cross sectional approach
library(tidyverse)
#Tidy Census is the library that connects to the Census API and allows you to pull the data
library(tidycensus)
# GGPLOT2 is one of the most popular data visualization packages.  You can make maps and anytype of plot you might want
library(ggplot2)
# Hmisc is another library that helps with the data manipulation
library(RColorBrewer) #library for olor palettes
library(Hmisc)
# SF is the simple features library that allows you work with the spatial datatype of simple features
library(sf)
# Leaflet Gives the base map
library(leaflet)
# Stringr
library(stringr)
# Allows us to export our leaflet map
library(htmlwidgets)


```

### Part 1 Finding your Census Variables


```{r census}

#First you will need to install your census api
#The census API should have been gotten from https://api.census.gov/data/key_signup.html
#using the census_api_key function here put in your api key.  
#If you want to not have to do this every time you want to download census data, then add the second argument of install=TRUE.  If you choose this, then you might need to restart R. 
#census_api_key("XXX", install =TRUE)
#alternative would be census_api_key("YOUR API KEY GOES HERE", install=TRUE)



#Loading the Possible Census Variables -----------------------------------
#Now we need to load the variables to determine which ones would be the best for us.
#using the load_variables() function to load an dataframe that tells you the codes for the variables we want to extract.
#First we will load the American Community Survey (ACS) 5 year estimates 2016-2020(last available ACS with tidycensus).
#First argument is the year,second is the dataset (acs is the complete ACS dataset), and third is just left as cache=false
ACS<-load_variables(2020, "acs5",cache=FALSE)


#Check out what it brought back.  Looks like 27,040 observations of 3 variables
head(ACS)
#now lets open the dataframe and catch all the codes for the topic you are most interested in.
View(ACS)


```

### Let's grab some variables

```{r vars}

#Race/ethnicity variables come in counts of the population
#Since it is counts, that is only going to pick up on the most populated areas and not based on concentration
#Due to this issue, we are going to have to do a simple calculation

#EXAMPLE 1- Grabbing the White alone population and turning it into a %
# Using the get ACS Function we can get these counts
#First we define the list of variables that we want to pull and give them better names then the code
#To make the list it just your objectlistname <- then c() which means combine items into a vector.  Then inside the c() you are defining your items and names.
#Since the names from the census API are those codes that don't have a lot of meaning, we give it meaning with the MHI =, where that code will be saved with the name MHI
Variables<-c(MHI = "B19013_001", # Median Household Income
             MHV = "B25077_001", # Median Home Value
             Totalpop = "B01003_001") # Total Population
             

County<-get_acs(geography = "county",  #Defining the spatial scale
                      variables = Variables, #grabbing the variables we defined previously
                      survey = "acs5",      # survey we are pulling is the ACS 5 year estimates
                      year = 2020,   # End year for the 5 year estimates- 2016-2020
                      output = "wide", # data format wide (cross sectional)
                      geometry=T) # Pulls the spatial data information with it.

#Check out your data a little bit, it brought back 3220 observations of 9 variables
#First 10 records/observations return
head(County)

# summary() provides an overview of the data
summary(County)

#Notice how there is two numbers and columns for each of the variables? ex. MHIE and MHIM
#MHIE or the ones with an E on the end are the estimate, while the MHIM or ones with M are margin of error
#For the purposes of this lab we only care about the estimates
#Lets clean up this data a little bit before we go too far
#Here we are just pulling out the columns we care about using the indexing dataframe[,c("column name","etc")]
Counties<-County[,c("GEOID", "NAME", "MHIE", "MHVE", "TotalpopE", "geometry")]

#Easy renaming of the variables
names(Counties)[names(Counties) =="MHIE"]<-"MHI"
names(Counties)[names(Counties) =="MHVE"]<-"MHV"
names(Counties)[names(Counties) =="TotalpopE"]<-"Totalpop"


```

###The Leaflet map

```{r leaf}

#Setting up the color palettes
#To get the color schemes you will need to set these up
#The instructions have the different color palettes you can choose
#domain is the data that you want to create breaks for.  Here the domain for each of these is the variable
#n says the number of colors and breaks that you will need.  By making that 10 here we are making a color palette for deciles or 10%.
# Lowest values would be in the bottom 10% and highest in the top 10%
palMHI<-colorQuantile(palette = "viridis", domain=Counties$MHI, n=10)
palMHV<-colorQuantile(palette = "RdYlBu", domain=Counties$MHV, n=10)
palpop<-colorQuantile(palette = "RdBu", domain=Counties$Totalpop, n=10)


#Named map
#this will take awhile
map <- Counties %>% # Data set you want to map and the '%>%' is a piping command which makes it keep moving forward 
  
  st_transform(crs = 4326) %>% # Setting the projection of our simple feature spatial dataframe to match the webmapping application
  
  leaflet() %>%  # Leaflet function which puts this all in motion
  
  setView(lng = -98.55, lat = 39.8098, zoom = 3) %>% # the lng and lat set the center point, while zoom chooses how zoomed in it is
  
  addTiles(group = "OSM (default)") %>%  #This sets the base map and the following addProviderTiles() are optional other basemaps
  
  #addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  
  addProviderTiles(providers$CartoDB.Positron, group = "Carto B") %>%
  
  addPolygons(group = "Total", #Add polygons is how we choose what we want to map.
    popup = paste("County: ", Counties$NAME, "<br>", #Pop up provides the pop up information if we were to click on the county, paste() pastes all the text together
  "Total Population: ", Counties$Totalpop, "<br>", #<br> is html code for new line.   
    "Median Household Income: ", "$", Counties$MHI, "<br>",
      "Median Home Value: ", "$", Counties$MHV, "<br>"),
        stroke = FALSE,
          smoothFactor = 0,
            fillOpacity = 0.7,
             color = ~ palpop(Totalpop)) %>% #Color palette or what the color scheme is.  You made these earlier and they need to match
  addLegend(position = "bottomleft", pal=palpop, values= Counties$Totalpop, #Legend for this polygon layer
            title="Percentile of County Total Population", group = "Total", opacity = 1) %>% 
  addPolygons(group = "MHI", #Next layer with the same set up as before.  We could add as many as the computer would let us. 
              popup = paste("County: ", Counties$NAME, "<br>",
                            "Total Population: ", Counties$Totalpop, "<br>",
                            "Median Household Income: ", "$", Counties$MHI, "<br>",
                            "Median Home Value: ", "$", Counties$MHV, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ palMHI(MHI)) %>%
  addLegend(position = "bottomright", pal=palMHI, values= Counties$MHI, 
            title="Percentile of County Median Household Income", group = "MHI", opacity = 1) %>% 
  addPolygons(group = "MHV",
              popup = paste("County: ", Counties$NAME, "<br>",
        "Total Population: ", Counties$Totalpop, "<br>",
          "Median Household Income: ", "$", Counties$MHI, "<br>",
            "Median Home Value: ", "$", Counties$MHV, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ palMHV(MHV)) %>%
  addLegend(position = "bottomleft", pal=palMHV, values= Counties$MHV, 
            title="Percentile of County Median Household Income", group = "MHV", opacity = 1) %>% 
#Here we hide two of the groups so that only one shows on loading
  hideGroup("MHI") %>% # Hides the MHI layer so it doesn't all pop up at load
  
  hideGroup("MHV") %>% # Hides the MHV layer so it all doesn't pop up at the load
  
  addLayersControl(  #Gives you the option to turn on and off different basemaps or layers.
    baseGroups = c("OSM (default)", "Toner Lite", "Carto B"),
    overlayGroups = c("Total", "MHI", "MHV"),
    options = layersControlOptions(collapsed = FALSE)) 
  

map #loads the map you just made, this will take awhile

#Saving the Html map
#first argument is the leaflet map, second is the file name and extension, and final is whether it is selfcontained
saveWidget(map, file="map1.html", selfcontained = T)


#Saving the shapefile
cty <- st_write(Counties, "counties.shp")

#plot the shapefile to test
ggplot(cty) + geom_sf(fill = "lightblue", color = "grey50")



```

### Smaller Defined Spatial Unit Example

```{r unit}

#Here is a small example to show how to pull out the Census Tracts for a specific MSA (the 6 county Detroit MSA)
#First we define a new dataframe.  Since it isn't all US counties, we call it DetroitMSACT
#You should notice some other differences in the code
#The geography was changed from "county" to "tract" because we want the smaller spatial unit
#variables, Survey, Year, Output stay the same (it will bring back same variables from same year in the same way)
#The state="" is new and here you could define the state.  We want the Detriot MSA so its only "MI", but if you wanted to add more, you could with state=c("MI", "OH", ...)
#The county= argument is also new.  here you can define the specific counties you would want to pull.  the c("county1name", "county2name", etc) comes from the MSA counties for 
DetroitMSACT<-get_acs(geography = "tract",  #Defining the spatial scale
                variables = Variables, #grabbing the variables we defined previously
                survey = "acs5",      # survey we are pulling is the ACS 5 year estimates
                year = 2020,   # End year for the 5 year estimates- 2016-2020
                output = "wide", # data format wide (cross sectional)
                state="MI", # Define which State you want to pull data from
                county= c("Wayne","Oakland", "Macomb", "Livingston", "St. Clair", "Lapeer"), # Defining the counties in the state that the data will come from
                geometry=T) # Pulls the spatial data information with it.


#First 10 records/observations return
head(DetroitMSACT)

#summary() provides an overview of the data
summary(DetroitMSACT)

#Lets clean up this data a little bit before we go too far
#Here we are just pulling out the columns we care about using the indexing dataframe[,c("column name","etc")]
Detroit<-DetroitMSACT[,c("GEOID", "NAME", "MHIE", "MHVE", "TotalpopE", "geometry")]
# Easy renaming of the variables
names(Detroit)[names(Detroit) =="MHIE"]<-"MHI"
names(Detroit)[names(Detroit) =="MHVE"]<-"MHV"
names(Detroit)[names(Detroit) =="TotalpopE"]<-"Totalpop"




```

#The Second Leaflet Map

```{r leaf2}

#Setting up the color palettes
DpalMHI<-colorQuantile(palette = "viridis", domain=Detroit$MHI, n=10)
DpalMHV<-colorQuantile(palette = "RdYlBu", domain=Detroit$MHV, n=10)
Dpalpop<-colorQuantile(palette = "RdBu", domain=Detroit$Totalpop, n=10)

#Named map
#this will take awhile
Detmap<-Detroit %>% # Data set you want to map and the '%>%' is a piping command which makes it keep moving forward 
  
  st_transform(crs = 4326) %>% # Setting the projection of our simple feature spatial dataframe to match the webmapping application
  
  leaflet() %>%  # Leaflet function which puts this all in motion
  
  setView(lng = -83.06, lat = 42.33, zoom = 8)%>% # the lng and lat set the center point, while zoom chooses how zoomed in it is
  
  addTiles(group = "OSM (default)") %>%  #This sets the base map and the following addProviderTiles() are optional other basemaps
  
  #addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  
  addProviderTiles(providers$CartoDB.Positron, group = "Carto B") %>%
  
  addPolygons(group = "Total", #Add polygons is how we choose what we want to map.
              popup = paste("Census Tract: ", Detroit$NAME, "<br>", #Pop up provides the pop up information if we were to click on the county, paste() pastes all the text together
              "Total Population: ", Detroit$Totalpop, "<br>", # <br> is html code for new line.   
      "Median Household Income: ", "$", Detroit$MHI, "<br>",
              "Median Home Value: ", "$", Detroit$MHV, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ Dpalpop(Totalpop)) %>% #Color palette or what the color scheme is.  You made these earlier and they need to match
  addLegend(position = "bottomleft", pal=Dpalpop, values= Detroit$Totalpop, #Legend for this polygon layer
            title="Percentile of Census Tract Total Population", group = "Total", opacity = 1) %>% 
  
  addPolygons(group = "MHI", #Next layer with the same set up as before.  We could add as many as the computer would let us. 
              popup = paste("Census Tract: ", Detroit$NAME, "<br>",
                    "Total Population: ", Detroit$Totalpop, "<br>",
                      "Median Household Income: ", "$", Detroit$MHI, "<br>",
                        "Median Home Value: ", "$", Detroit$MHV, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ DpalMHI(MHI)) %>%
  
  addLegend(position = "bottomright", pal=DpalMHI, values= Detroit$MHI, 
            title="Percentile of Census Tract Median Household Income", group = "MHI", opacity = 1) %>% 
  
  addPolygons(group = "MHV",
              popup = paste("Census Tract: ", Detroit$NAME, "<br>",
                "Total Population: ", Detroit$Totalpop, "<br>",
                "Median Household Income: ", "$", Detroit$MHI, "<br>",
                  "Median Home Value: ", "$", Detroit$MHV, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ DpalMHV(MHV)) %>%
  
  addLegend(position = "bottomleft", pal=DpalMHV, values= Detroit$MHV, 
            title="Percentile of Census Tract Median Household Income", group = "MHV", opacity = 1) %>% 
  
  # Here we hide two of the groups so that only one shows on loading
  hideGroup("MHI") %>% # Hides the MHI layer so it doesn't all pop up at load
  
  hideGroup("MHV") %>% # Hides the MHV layer so it all doesn't pop up at the load
  
  addLayersControl(  #Gives you the option to turn on and off different basemaps or layers.
    baseGroups = c("OSM (default)", "Toner Lite", "Carto B"),
    overlayGroups = c("Total", "MHI", "MHV"),
    options = layersControlOptions(collapsed = FALSE)) 

Detmap # loads the map you just made, this will take awhile

#Saving the Html map
#first argument is the leaflet map, second is the file name and extension, and final is whether it is selfcontained
#The space needed for the self contained file is a lot which is why we reduced it down to just one layer.
saveWidget(Detmap, file="Detmap.html", selfcontained = T)



```

### Making New Map with Census Data

```{r kzoodata}

#What is the racial, occupational, and degree type for those who have one, and median household income of Kalamazoo Metropolitan Statistical Area? For the 5-yr 2016-2020 data

#Note that not all of this data may be used in the final map, just looking at this data for ideas.

#MHI is % of a median for the whole area (B01003)

#Racial is % of whole estimated population of each census tract, total (B02001_001) larger code groups are: White (B02001_002), Black or African American (B02001_003), Asian (B02001_005), American Indian or Alaska Native (B02001_004), Native Hawaiian and Other Pacific Islander (B02001_006), Some Other Race (B02001_007), Two or More Races (B02001_008)

#Degree type is % of degree in x field for each census tract as a % of all degrees, total (B15012_001) the 5-group classes are: Science and Engineering (combine)Science and Engineering Related (c(B15012_002, B15012_003, B15012_004, B15012_005, B15012_006, B15012_007, B15012_008, B15012_009)), Business (B15012_010), Education (B15012_011), Art, Humanities and Other (c(B15012_012, B15012_013, B15012_014, B15012_015, B15012_016). 

#Occupation is % of all occupations of the area (by industry) (civilian) by census tract:
#Total (C24040_001), 
#Male(C24040_002), Female (C24040_029)
#Agriculture, forestry, fishing and hunting, and mining (C24040_003), (C24040_030) res
#Construction (C24040_006) (C24040_033) con
#Manufacturing (C24040_007) (C24040_034) manu
#Wholesale trade (C24040_008) (C24040_035) whol
#Retail trade (C24040_009) (C24040_036) ret
#Transportation and warehousing, and utilities (C24040_010) (C24040_037) trans
#Information (C24040_013) (C24040_040) info
#Finance and insurance, and real estate, and rental and leasing (C24040_014) (C24040_041) fin
#Professional, scientific, and management, and administrative, and waste management services (C24040_017) (C24040_044) prof
#Educational services, and health care and social assistance (C24040_021) (C24040_048) edu
#Arts, entertainment, and recreation, and accommodation and food services (C24040_024) art (C24040_051)
#Other services, except public administration (C24040_027) (C24040_054) other
#Public administration (C24040_028) (C24040_055) pub


vars <- load_variables(2020, "acs5", cache = TRUE)
#write_csv(vars, "5yrACSVariables.csv")

vari <- c(med_inc = "B19013_001", tot_pop = "B01003_001", tot_race = "B02001_001", white = "B02001_002", black = "B02001_003", asian = "B02001_005", native = "B02001_004", pacific = "B02001_006", other = "B02001_007", two = "B02001_008", #income, population, and race

tot_deg = "B15012_001", sci1_deg = "B15012_002", sci2_deg = "B15012_003", sci3_deg = "B15012_004", sci4_deg = "B15012_005", sci5_deg = "B15012_006", sci6_deg = "B15012_007", sci7_deg = "B15012_008", sci8_deg = "B15012_009", bus_deg = "B15012_010", ed_deg = "B15012_011", hum1_deg = "B15012_012", hum2_deg = "B15012_013", hum3_deg = "B15012_014", hum4_deg = "B15012_015", hum5_deg = "B15012_016",  #degree variable

tot_occ = "C24040_001", male_occ = "C24040_002", female_occ = "C24040_029",
resm = "C24040_003", resf = "C24040_030", 
conm = "C24040_006", conf = "C24040_033", 
manum = "C24040_007", manuf = "C24040_034", 
wholm = "C24040_008", wholf = "C24040_035",
retm = "C24040_009", retf = "C24040_036", 
transm = "C24040_010", transf = "C24040_037",
infom = "C24040_013", infof = "C24040_040", 
finm = "C24040_014", finf = "C24040_041", 
profm = "C24040_017", proff = "C24040_044",
edum = "C24040_021", eduf = "C24040_048",
artm = "C24040_024", artf = "C24040_051",
otherm = "C24040_027", otherf = "C24040_054",
pubm = "C24040_028", pubf = "C24040_055") #occupations

  

#get data and filter to estimates
                
kzooacs<-get_acs(geography = "tract", variables = vari,  year = 2020, survey = "acs5", output = "wide", state ="MI", county = "Kalamazoo", geometry=T) %>% select(., !ends_with("M"))

#selecting needed columns and summing needed columns
kzoodat <- kzooacs %>% 
  mutate(., science_deg = rowSums(across(starts_with("sci")), na.rm = TRUE), .after = "tot_degE", .keep = "unused") %>% 
  
  mutate(., human_deg = rowSums(across(starts_with("hum")), na.rm = TRUE), .after = "science_deg", .keep = "unused") %>%
  
 
  mutate(., res_occ = rowSums(across(starts_with("res")), na.rm = TRUE), .after = "tot_occE", .keep = "unused") %>%
  
  mutate(., con_occ = rowSums(across(starts_with("con")), na.rm = TRUE), .after = "res_occ", .keep = "unused") %>%
  
   mutate(., manu_occ = rowSums(across(starts_with("manu")), na.rm = TRUE), .after = "con_occ", .keep = "unused") %>%
  
    mutate(., whol_occ = rowSums(across(starts_with("whol")), na.rm = TRUE), .after = "manu_occ", .keep = "unused") %>%

     mutate(., ret_occ = rowSums(across(starts_with("ret")), na.rm = TRUE), .after = "whol_occ", .keep = "unused") %>%
  
     mutate(., trans_occ = rowSums(across(starts_with("trans")), na.rm = TRUE), .after = "ret_occ", .keep = "unused") %>%
  
  mutate(., info_occ = rowSums(across(starts_with("info")), na.rm = TRUE), .after = "trans_occ", .keep = "unused") %>%

 mutate(., fin_occ = rowSums(across(starts_with("fin")), na.rm = TRUE), .after = "info_occ", .keep = "unused") %>%

  mutate(., prof_occ = rowSums(across(starts_with("prof")), na.rm = TRUE), .after = "fin_occ", .keep = "unused") %>%
  
  mutate(., fin_occ = rowSums(across(starts_with("fin")), na.rm = TRUE), .after = "prof_occ", .keep = "unused") %>%

  mutate(., edu_occ = rowSums(across(starts_with("edu")), na.rm = TRUE), .after = "info_occ", .keep = "unused") %>%
  
 mutate(., art_occ = rowSums(across(starts_with("art")), na.rm = TRUE), .after = "edu_occ", .keep = "unused") %>%
  
  mutate(., other_occ = rowSums(across(starts_with("other")), na.rm = TRUE), .after = "art_occ", .keep = "unused") %>%
  
 mutate(., pub_occ = rowSums(across(starts_with("pub")), na.rm = TRUE), .after = "art_occ", .keep = "unused")   %>%
  
 mutate(., max_med_inc = max(med_incE, na.rm = TRUE), .after = "med_incE") %>% 
 
mutate(., med_incper = (med_incE/max_med_inc)*100, .after = "max_med_inc")  
  
#write_csv(kzoodat, "kazoocensusdat.csv")  
  
  
  
  
```

#The New Map

```{r kzoo}

#map palettes
palmed_inc<-colorQuantile(palette = "RdBu", domain= kzoodat$med_incE, n=10)
palpop<-colorQuantile(palette = "PRGn", domain= kzoodat$tot_popE, n=10)

#looking at black population distribution in the city
palblk <- colorQuantile(palette = "YlOrRd", domain =kzoodat$blackE, n = 10)



#quartiles slice up the (ranked) dataset into a median value at 50% (Q2), a median of the values below the 50% for Q, and median of values below Q3 is Q2, median of values above Q2 is Q3

#but to find a q-quantile, you can follow a similar method to that used for quartiles, except in steps 3–5, multiply n by multiples of 1/q instead of 1/4.

#For example, to find the third 5-quantile:

#Calculate n * (3 / 5).
#If  n * (3 / 5) is an integer, then the third 5-quantile is the mean of the numbers at positions  n * (3 / 5) and n * (3 / 5) + 1.
#If n * (3 / 5) is not an integer, then round it up. The number at this position is the third 5-quantile.


#0 quartile = 0 quantile = 0 percentile

#1 quartile = 0.25 quantile = 25 percentile

#2 quartile = .5 quantile = 50 percentile (median)

#3 quartile = .75 quantile = 75 percentile

#4 quartile = 1 quantile = 100 percentile


kzoomap <- kzoodat %>% st_transform(crs = 4326) %>% 
  
  leaflet() %>% setView(lng = -85.584, lat = 42.290, zoom = 10) %>%  #the lng and lat set the center point, while zoom chooses how zoomed in it is
  
  addTiles(group = "OSM (default)") %>%  #This sets the base map and the following 
  addProviderTiles(providers$CartoDB.Positron, group = "Carto B") %>% #addProviderTiles() are optional other basemaps
  
  
  addPolygons(group = "POP", #Add polygons is how we choose what we want to map.
              popup = paste("Census Tract: ", kzoodat$NAME, "<br>", #Pop up provides the pop up information if we were to click on the county, paste() pastes all the text together
              "Total Population: ", kzoodat$tot_popE, "<br>",               
              "Median Household Income: ", "$", kzoodat$med_incE, "<br>",
              "Black Only Race Classfication: ", kzoodat$blackE, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ palpop(tot_popE)) %>% #Color palette or what the color scheme is.  You made these earlier and they need to match
  
        addLegend(position = "bottomleft", pal=palpop, values= kzoodat$tot_popE, #Legend for this polygon layer
            title="Percentile of Census Tract<br>Total Population", group = "Total", opacity = 0.7) %>% 
  
  addPolygons(group = "MHI", #Next layer with the same set up as before.  We could add as many as the computer would let us. 
              popup = paste("Census Tract: ", kzoodat$NAME, "<br>",
                    "Total Population: ", kzoodat$tot_popE, "<br>",
                    "Median Household Income: ", "$", kzoodat$med_incE, "<br>",
                    "Black Only Race Classfication: ", kzoodat$blackE, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ palmed_inc(med_incE)) %>%
  
  addLegend(position = "bottomright", pal=palmed_inc, values= kzoodat$med_incE, 
            title="Percentile of Census Tract<br>Median Household Income", group = "Med_Inc", opacity = 0.7) %>% 
  
  
addPolygons(group = "BLK", #Add polygons is how we choose what we want to map.
              popup = paste("Census Tract: ", kzoodat$NAME, "<br>", #Pop up provides the pop up information if we were to click on the county, paste() pastes all the text together
              "Total Population: ",  kzoodat$tot_popE, "<br>", # <br> is html code for new line. 
              "Median Household Income: ", "$", kzoodat$med_incE, "<br>",
              "Black Only Race Classfication: ", kzoodat$blackE, "<br>"),
              stroke = FALSE,
              smoothFactor = 0,
              fillOpacity = 0.7,
              color = ~ palblk(blackE)) %>% #Color palette or what the color scheme is.  You made these earlier and they need to match
  
        addLegend(position = "topleft", pal=palblk, values= kzoodat$blackE, #Legend for this polygon layer
            title="Percentile of Census Tract<br>Black Only Race Classfication", group = "Black", opacity = 0.7) %>% 
  
  # Here we hide two of the groups so that only one shows on loading
  hideGroup("POP") %>% # Hides the MHI layer so it doesn't all pop up at load
  
  hideGroup("MHI") %>% # Hides the MHV layer so it all doesn't pop up at the load
  
  addLayersControl(  #Gives you the option to turn on and off different basemaps or layers.
    baseGroups = c("OSM (default)", "Carto B"),
    overlayGroups = c("POP", "MHI", "BLK"),
    options = layersControlOptions(collapsed = FALSE)) 

kzoomap # loads the map you just made

#Saving the Html map
#first argument is the leaflet map, second is the file name and extension, and final is whether it is selfcontained
#The space needed for the self contained file is a lot which is why we reduced it down to just one layer.
saveWidget(kzoomap, file="kzoomap.html", selfcontained = T)




```

